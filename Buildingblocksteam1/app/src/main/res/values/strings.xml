<resources>
    <string name="app_name">Building blocks team 1</string>
    <string name="action_settings">Settings</string>
    <string name="title">buildingBlocks</string>
    <!-- Strings used for fragments for navigation -->
    <string name="first_fragment_label">First Fragment</string>
    <string name="second_fragment_label">Second Fragment</string>
    <string name="next">Next</string>
    <string name="previous">Previous</string>
    <string name="home_button_to_signup_text">Sign Up</string>

    <string name="logo">Logo</string>
    <string name="home_daily">Daily Quiz</string>
    <string name="home_lessons">Lessons</string>
    <string name="home_flashcards">Flash Cards</string>

    <!--Strings for login Page  -->
    <string name="login_button_text">Login</string>
    <string name="login_password_text">Password</string>
    <string name="login_password_hint">Enter Password</string>
    <string name="login_username_text">Username</string>
    <string name="login_username_hint">Enter Username</string>
    <string name="login_title">Hello Again!</string>
    <string name="login_forgot_password">Forgot password?</string>
    <string name="login_clicked_wrong_page_text">If you do not have an account:</string>
    <string name="login_to_signup_text"><u>Sign up</u></string>

    <string name="hello_first_fragment">buildingBlocks</string>
    <string name="hello_second_fragment">Hello second fragment. Arg: %1$s</string>
    <!-- Strings related to login -->
    <string name="prompt_email">Email</string>
    <string name="prompt_password">Password</string>
    <string name="action_sign_in">Sign in or register</string>
    <string name="action_sign_in_short">Sign in</string>
    <string name="welcome">"Welcome!"</string>
    <string name="invalid_username">Not a valid username</string>
    <string name="invalid_password">Password must be greater than 5 characters</string>
    <string name="login_failed">"Login failed"</string>

    <!-- Strings about signup -->
    <string name="signup_title">Hello!</string>
    <string name="signup_confirm_email">Confirm Email</string>
    <string name="signup_username">Username</string>
    <string name="signup_confirm_password">Confirm Password</string>
    <string name="signup_button_text">Sign Up!</string>
    <string name="signup_clicked_wrong_page_test">If you already have an account:</string>
    <string name="signup_to_login_text"><u>Login!</u></string>
    <string name="signed_out">Signed out</string>
    <string name="verify_email">Verify Email</string>
    <string name="sign_out">Sign Out</string>

    <string name="reload">Reload</string>

    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="sign_out_text">Sign out</string>

    <!-- Quiz Stuff -->
    <string name="quiz_title">Quizzes Menu</string>
    <string name="quiz_text">I need a lot of text dawg if I want to reach the end of the page to see if I can scroll view it. I need to make sure that there is enough text</string>
    <string name="quiz_linked_list">LinkedList Quiz</string>
    <string name="quiz_array_list">ArrayList Quiz</string>
    <string name="quiz_placeholder1">Placeholder</string>
    <string name="quiz_placeholder2">Placeholder2</string>
    <string name="bubble_sort">Start with an array of unsorted numbers
Define a function called “bubbleSort” that takes in the array and the length of the array as parameters
In the function, create a variable called “sorted” that is set to true
Create a for loop that iterates through the array starting at index 0 and ending at the length of the array -1
Within the for loop, compare the current element with the next element in the array
If the current element is greater than the next element, swap their positions and set “sorted” to false
After the for loop, check if “sorted” is false
If “sorted” is false, call the “bubbleSort” function again with the same array and length as parameters
If “sorted” is true, the array is now sorted and the function will return the sorted array
Call the “bubbleSort” function with the initial unsorted array and its length as parameters to begin the sorting process.</string>
    <string name="linked_list_lec">Random access is not allowed. We have to access elements sequentially starting from the first node(head node). So we cannot do a binary search with linked lists efficiently with its default implementation.
Extra memory space for a pointer is required with each element of the list.
Not cache-friendly. Since array elements are contiguous locations, there is the locality of reference which is not there in the case of linked lists.
It takes a lot of time in traversing and changing the pointers.
Reverse traversing is not possible in singly linked lists.
It will be confusing when we work with pointers.
Direct access to an element is not possible in a linked list as in an array by index.
Searching for an element is costly and requires O(n) time complexity.
Sorting of linked lists is very complex and costly.
Appending an element to a linked list is a costly operation, and takes O(n) time, where n is the number of elements in the linked list, as compared to arrays that take O(1) time.</string>

    <string name="hash_tables_lec">Data Structure: A hash table is a data structure that allows efficient storage and retrieval of key-value pairs. It is also known as a hash map, hash map, or associative array.
Hash Function: A hash table uses a hash function to convert the keys into an index or a hash code, which determines the location in the underlying array where the value will be stored. The hash function should ideally distribute the keys uniformly across the array to minimize collisions.
Collisions: Collisions occur when two or more keys produce the same hash code or index. Hash tables employ collision resolution techniques, such as chaining or open addressing, to handle collisions and store multiple values at the same index.
Efficient Retrieval: Hash tables offer constant-time (O(1)) average-case complexity for retrieval, insertion, and deletion operations. This means that the time required to perform these operations does not depend on the number of elements stored in the hash table.
Trade-Offs: Hash tables trade space for time. They require additional memory to store the underlying array and handle collisions efficiently. The load factor, defined as the ratio of the number of stored elements to the size of the array, affects the performance of the hash table. A higher load factor increases the likelihood of collisions.
Resizing: Hash tables often dynamically resize themselves to maintain an optimal load factor. When the number of elements exceeds a certain threshold, the hash table is resized by creating a larger underlying array and rehashing the existing elements to distribute them evenly.
Applications: Hash tables are widely used in various applications. They are particularly useful for implementing lookup tables, symbol tables, caches, and data indexing structures. They provide efficient access to data and are essential in many algorithms and data processing systems.</string>

    <string name="graphs_lec">Graphs are mathematical structures used to represent and analyze relationships between objects or entities. They consist of nodes (also known as vertices) and edges that connect the nodes.
Graphs can be used to model various real-world scenarios, such as social networks, transportation systems, computer networks, and biological interactions.
The nodes in a graph can represent different entities, such as people, cities, or web pages. The edges represent the connections or relationships between these entities.
Graphs can be classified into different types based on their properties. Some common types include directed graphs (where edges have a specific direction), undirected graphs (where edges have no specific direction), weighted graphs (where edges have assigned values or weights), and bipartite graphs (where nodes can be divided into two disjoint sets).
Graphs can be traversed or searched using various algorithms such as depth-first search (DFS) and breadth-first search (BFS). These algorithms help explore and analyze the structure and connectivity of a graph.
Graph theory is a branch of mathematics that deals with the study of graphs. It provides a framework for analyzing and solving problems related to graphs, including finding the shortest path between nodes, identifying cycles, and determining connectivity.
Graphs have numerous practical applications in various fields. For example, they are used in data science for analyzing relationships between variables, in computer science for designing algorithms and data structures, in logistics for optimizing transportation routes, and in social sciences for studying interactions and networks of individuals.</string>

    <string name="heaps_lec">A heap is a specialized tree-based data structure that satisfies the heap property. The heap property states that for every node in the heap, the value of the node is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the values of its children.
Heaps are commonly used to implement priority queues, where elements with higher priorities are extracted before elements with lower priorities.
Heaps are typically implemented using an array or a binary tree. Heap operations include inserting a new element, extracting the maximum (or minimum) element, and heapifying (rearranging the elements to maintain the heap property) the heap after modifications.
The time complexity of the basic heap operations is efficient. Inserting an element or extracting the maximum (or minimum) element takes O(log n) time, where n is the number of elements in the heap.
Heapsort is an efficient sorting algorithm that utilizes the heap data structure. It first builds a max heap (for sorting in non-decreasing order) or a min heap (for sorting in non-increasing order) from the input array and then repeatedly extracts the maximum (or minimum) element to obtain a sorted array. The time complexity of heapsort is O(n log n), making it suitable for large datasets.</string>

</resources>
